# Development & Collaboration Workflow

This document defines **how Loophole is implemented**, not what it does.

It describes how:

- You (the human developer),
- ChatGPT (architect / reviewer),
- Cursor (local code + doc editor),
- Codex CLI (optional bridge to ChatGPT),

work together across the four main repositories:

- `loophole-signal` – C++ / JUCE audio engine
- `loophole-pulse` – Rust model/server (medium term; may bootstrap in TypeScript)
- `loophole-aura` – Electron / TypeScript UI
- `loophole-chorus` – Architecture, specs, IPC, meta

The goal is to keep the workflow **predictable, low-friction and safe**, while
preserving the “architecture first” philosophy.

---

## 1. Roles

### 1.1 You (Human Developer)

You are the **product owner and final authority** on:

- Musical UX, workflows, and priorities
- Architectural trade-offs and long-term direction
- Code style and repo conventions
- When a spec is “good enough” to implement

You:

- Decide what to work on next
- Run builds, tests, and profiling
- Integrate external tools and libraries
- Approve / adapt any AI-generated code

### 1.2 ChatGPT (Architect / Reviewer)

In this context, ChatGPT acts primarily as:

- **System architect** – shaping high-level design and specs
- **Specification author** – writing and refining docs in Chorus
- **Code reviewer / advisor** – suggesting patterns, spotting design issues
- **Prompt author** – writing “meta prompts” for Cursor and Codex

ChatGPT does **not**:

- Run code, build projects, or access your local filesystem
- Directly edit your repos (that’s Cursor’s job)
- Make unilateral breaking changes to architecture without discussion

### 1.3 Cursor (Local Code & Doc Editor)

Cursor is the **hands-on engineer** working on your local checkout:

- Edits code and documentation
- Applies prompts written here
- Runs searches and refactors within your repos
- Keeps cross-references and filenames consistent

You control when Cursor runs tasks and how its suggestions are applied.

### 1.4 Codex CLI (Optional Bridge)

Codex CLI:

- Provides a **terminal-based agent** that can:
  - Call ChatGPT with repo context
  - Apply patches to files
- Is useful if you want direct ChatGPT-driven edits in code, outside Cursor’s UI.

Use it when:

- You want “vibe coding” with ChatGPT deeply inside a repo context.
- You’re comfortable reviewing patches before committing.

---

## 2. Core Principles

1. **Architecture first, code second**
   - Any non-trivial feature must first exist in **Chorus** as:
     - An architecture doc, and/or
     - An IPC/spec update, and/or
     - A decision record.
   - Only then do we implement it in Signal / Pulse / Aura / Composer.

2. **Chorus is the source of truth**
   - Runtime repos must follow the contracts defined in `loophole-chorus`.
   - If reality diverges, we fix the docs *or* consciously log a decision.

3. **Small, focused steps**
   - Each change (doc or code) should:
     - Do one clear thing,
     - Be easy to review,
     - Not rewrite the world.

4. **No silent protocol changes**
   - Any change to IPC schemas or domain semantics:
     - Must be reflected in `docs/specs/ipc/**/*`,
     - Must be checked for cross-repo impact.

5. **Reports are immutable**
   - Files in `docs/reports/` are historical:
     - **Never** edited or regenerated by Cursor or ChatGPT.
     - New reports always go in `docs/reports/YYYY-MM-DD-HHMMSS-<slug>.md`.

6. **Quad backticks in this chat**
   - Whenever ChatGPT emits a whole file, it is wrapped in **quad backticks**,
     with nested triple-backtick code blocks kept intact for easy copy/paste.

---

## 3. Where Work Happens

### 3.1 Chorus (Architecture & Specs)

**Types of changes here:**

- New or updated architecture docs (`docs/architecture/*.md`)
- IPC specifications (`docs/specs/ipc/**/*`)
- Meta / process docs (`docs/meta/*.md`)
- Decision records (`docs/decisions/*.md`)
- Reports (`docs/reports/*.md`)

**Typical flow:**

1. **Discuss idea** in ChatGPT:
   - Architectural impact
   - Interaction with existing docs
2. **ChatGPT drafts** the doc/content in this chat (quad-backtick block).
3. You:
   - Paste content into the right file (or ask Cursor to),
   - Or run a Cursor prompt written by ChatGPT to update multiple files.
4. Optionally:
   - Run cohesion / consistency passes via a Cursor “review” prompt.

Chorus is where we “shape reality” before any code is written.

---

### 3.2 Pulse (Rust model / server)

Pulse will be:

- The **authoritative model** for projects, tracks, lanes, nodes, parameters.
- The **single gateway** for Aura ↔ Signal communication.
- Implemented in **Rust** (with a possible very early TS bootstrap if needed).

**Types of tasks:**

- Implement domain models consistent with `docs/architecture/0X-*.md`
- Implement IPC handlers matching `docs/specs/ipc/pulse/*.md`
- Implement persistence and project loading
- Coordinate with Signal for graph construction and cohorts

**Typical flow for a feature:**

1. Identify the relevant **architecture doc** and **IPC spec**.
2. Ask ChatGPT:
   - For a **high-level implementation sketch** (Rust modules, types, services).
3. Use Cursor:
   - To scaffold modules and types,
   - To implement handlers and tests,
   - To align names/IDs with specs.
4. You:
   - Review and refine code,
   - Run tests and benchmarks,
   - Push to GitHub.

We treat Pulse as a **long-lived Rust service**, so correctness and clarity are
more important than rushing.

---

### 3.3 Signal (C++ / JUCE Engine)

Signal is:

- A **small, high-performance** C++ engine,
- Focused on audio processing, plugins, cohorts, and real-time safety.

**Types of tasks:**

- Implement cohort architecture and processing graphs.
- Implement IPC handling for `docs/specs/ipc/signal/*.md`.
- Integrate JUCE plugin hosting, hardware, and media streaming.
- Implement safety guarantees (sandboxing, isolation, crash recovery).

**Typical flow:**

1. Start from the relevant Signal architecture doc (`02-signal.md`, cohort doc, etc.).
2. Ask ChatGPT:
   - For C++ class sketches,
   - For threading / real-time-safety advice,
   - For JUCE integration patterns.
3. Use Cursor:
   - To create/modify C++ modules,
   - To maintain clear separation between audio thread and control thread.
4. You:
   - Run builds and plug-in scans,
   - Test performance and stability,
   - Make final design adjustments.

---

### 3.4 Aura (Electron / TypeScript UI)

Aura handles:

- UI rendering and interaction,
- Editor views, clip launcher, mixer,
- Plugin browser, plugin UIs, media library views.

**Types of tasks:**

- Implement React/Vue-style components (within Electron).
- Implement IPC client for Pulse.
- Create interactive tools (piano roll, automation editor, media browser).
- Integrate control surfaces visually.

**Typical flow:**

1. Identify relevant UX/architecture docs:
   - `26-ux-and-visual-layer.md`
   - Editor / media / plugin browser docs.
2. Ask ChatGPT:
   - For component design,
   - For state management patterns,
   - For IPC call flows.
3. Use Cursor:
   - To scaffold TS/JS components,
   - To wire IPC layer.
4. You:
   - Refine UX,
   - Add styling,
   - Wire real data.

---

### 3.5 Composer

Composer is:

- A **metadata and intelligence** service:
  - plugin metadata and roles,
  - parameter mapping,
  - deterministic vs non-deterministic classification,
  - hardware device intelligence.

Implementation details will follow its architecture doc, but the workflow is the
same: spec first in Chorus, then data model and API implementation in its own repo.

---

## 4. Change Lifecycle

### 4.1 From Idea → Arch → IPC → Code

1. **Idea surfaces**
   - In this chat or in `docs/meta/architecture-inbox.md`.
2. **Backlog alignment**
   - If it’s substantial, add/confirm it in `architecture-backlog.md`.
3. **Architecture doc**
   - Create or update a doc in `docs/architecture/` to describe the concept.
4. **IPC / Contract**
   - Update/add IPC specs in `docs/specs/ipc/**/*` if any cross-process calls are needed.
5. **Decision record (optional but encouraged)**
   - For significant or contentious choices, add a `docs/decisions/` entry.
6. **Implementation**
   - Use Cursor (and optionally Codex CLI) to implement the feature in the relevant repo.

### 4.2 Spec Changes After Code Exists

If we need to change a spec **after** code is written:

1. Update the architecture and IPC docs **first**.
2. Mark any breaking change clearly in the docs.
3. Implement changes in:

   - Pulse,
   - Signal,
   - Aura,

   in a controlled sequence (usually Pulse → Signal → Aura).
4. Consider adding a short report in `docs/reports/` summarising the change.

---

## 5. Working With Cursor

When ChatGPT writes prompts for Cursor, they will:

- Be **file-specific** and explicit,
- Avoid ambiguity about:
  - which files to change,
  - which files **not** to touch (especially `docs/reports/`),
- Ask Cursor to:
  - summarise all changes in a report file:
    - `docs/reports/YYYY-MM-DD-HHMMSS-<slug>.md`

You then:

- Run the prompt in Cursor,
- Review changes,
- Commit when satisfied.

---

## 6. Working With Codex CLI

If/when you use Codex CLI:

- Treat it as a **narrow, localised agent**:
  - For intense refactors in a single repo,
  - For complex code generation tasks with deep context.
- Keep Chorus as the **contract authority**:
  - If Codex proposes changes that deviate from specs,
  - We reconcile them here and update the docs if needed.

---

## 7. What To Ask ChatGPT For

Good examples of things to throw at this chat:

- “Draft an architecture doc for X feature.”
- “Give me a Cursor prompt to refactor Y across all IPC files.”
- “Sketch the Rust types for the Pulse model representing Z.”
- “Help me design a JUCE-friendly Signal class layout for this graph.”
- “Review this architecture doc and suggest missing edge cases.”
- “Translate this architecture concept into a concrete TS component hierarchy.”

Less ideal:

- Tiny cosmetic changes (better handled directly in Cursor).
- Repo-specific edits where Cursor already has full context and a good suggestion.

---

## 8. Summary

- **Chorus** defines reality.  
- **Pulse, Signal, Aura, Composer** implement it.  
- **ChatGPT** shapes architecture and specs, writes prompts, and reviews designs.  
- **Cursor** edits code and docs locally.  
- **You** steer everything, run the builds, and make the final calls.

This workflow is designed to minimise rework, keep the system coherent, and let
you move very fast without sacrificing architectural quality.
